# -*- coding: utf-8 -*-
#
# This file is part of AUSPEX.
#
# AUSPEX
#
# Copyright 2016-17 by the Medical Research Council, Andrea Thorn 
# and Diamond Lightsource Ltd.
#
# Authors: Andrea Thorn, Rob Nicholls, James Parkhurst and Paul Emsley
#
# AUSPEX is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# AUSPEX is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with AUSPEX. If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
from __future__ import division
from builtins import str
from builtins import zip
from builtins import range
from builtins import object
import string #importiere Modul string

import sys

import os
from os.path import basename, splitext

import math

import matplotlib


import numpy as np
#import pdb

import auspex

from distutils import sysconfig

import argparse
from argparse import RawTextHelpFormatter

from os.path import exists


# agg is a backend which is independent of a graphicscard etc.
# similar to device in R agg = antialiasing
matplotlib.use('agg')
import matplotlib.pyplot as plt

# Set the font size and then set the maths font to san-serif
matplotlib.rcParams['font.size'] = 8
matplotlib.rcParams['mathtext.fontset'] = 'stixsans'

class IceRingTextReader(object):
    #Helper class to read ice ring text file
    def __init__(self, filename):
        #Read in the text file
        with open(filename) as infile:
            self.lower = []
            self.upper = []
            for line in infile.readlines():
                tokens = line.split()
                assert len(tokens) == 2
                self.lower.append(float(tokens[0]))
                self.upper.append(float(tokens[1]))


class GenericPlot(object):
    '''
    A class to do a generic plot for Auspex

    '''

    def __init__(self, 
                 ice_rings,
                 filename=None,
                 output_directory=None,
                 ylim=None,
                 dmin=None,
                 filename_in_title=False,
                 cutoff=5,
                 num_xticks=10,
                 no_automatic=False,
                 ax=None):
        '''
        Initialize with the ice ring resolutions

        '''

        # Save the ice rings
        self.ice_rings = ice_rings

        # Save some params
        self.mtzfilename = filename
        self.ylim = ylim
        self.dmin = dmin
        self.filename_in_title = filename_in_title

        # Set the plot size
        self.plotwidth = 8
        self.dpi = 300

        # Set number of x ticks
        self.num_xticks = num_xticks

        # Set the label padding
        self.xlabelpad = 4
        self.ylabelpad = 3
        self.titlepos = 1.02

        # Own figure
        self.ax = ax

        # Set cutoff
        self.cutoff = cutoff

        # Set if red bars should be shown.
        self.no_automatic = no_automatic

        # Set the output directory
        self.output_directory = output_directory
        self.name_stub = "output"


    def get_ymax(self, y_data, multiplier):

        ymax = min(max(y_data),(( sum(y_data)/len(y_data) )+ multiplier*(np.std(y_data)) ))
        return ymax

    def generate(self, auspex_handle, resolution, y_data):
        '''
        Generate the plot

        '''
        # Setup the plot 1
        if self.ax is None:
            figure = plt.figure(figsize=(self.plotwidth, np.sqrt(2)/3*self.plotwidth)) #TODO: Implement adjustable ratio
            # figure = plt.figure(figsize=(self.plotwidth, self.plotwidth / 1.62))
            ax1 = figure.add_subplot(111)
        else:
            ax1 = self.ax

        #Define function that calculates 1/x^2
        def formatter(x, p):
            if x <= 0:
                return ''
            else:
                return '%.2f' % math.sqrt(1.0/x)

        # Label the ticks in angstroms
        ax1.get_xaxis().set_major_formatter(matplotlib.ticker.FuncFormatter(formatter))

        # Set the number of x ticks
        ax1.set_xticks(
            np.arange(
                min(resolution), 
                max(resolution), 
                0.99*(max(resolution) - min(resolution)) / (self.num_xticks-1)))

        # Label the axes 
        ax1.set_xlabel(self.xlabel, labelpad=self.xlabelpad)
        ax1.set_ylabel(self.ylabel, labelpad=self.ylabelpad)
        if self.filename_in_title:
            ax1.set_title("%s\n %s" % (self.title, self.mtzfilename.replace("_",r"\_")), y=self.titlepos)
        else:
            ax1.set_title(self.title, y=self.titlepos)

        # Plot the points
        point_size = 4
        ax1.scatter(
            resolution, 
            y_data, 
            point_size, 
            zorder=2, 
            color="#0d0d0d", 
            alpha=0.7*math.exp(-len(y_data)*0.00004)+0.020, 
            linewidth=0)

        # Plot a teal line at y = 0
        ax1.axhline(0, color='#415a55', alpha=0.5)

        ## Compute the mean iobs etc
        #i_res_squared = []
        #mean_iobs = []
        #sd_iobs = []
        #for idx in range(auspex_handle.Size()):
        #i_res_squared.append(auspex_handle.MeanIResSquared(idx))
        #mean_iobs.append(auspex_handle.ObsMean(idx))
        #sd_iobs.append(math.sqrt(auspex_handle.ObsVar(idx)))

        # Set the plot limits
        xmax = max(resolution)
        xmin = min(0, min(resolution))
        #print "Reflection data: %s" % (len(y_data))
        if self.ylim == 'auto':
            ymax = self.get_ymax(y_data, 3)
            ymin = min(0, max(min(y_data),-ymax))
        elif self.ylim == 'auto_low':
            ymax = self.get_ymax(y_data, 2)
            ymin = min(0, min(y_data))
        elif self.ylim == 'low':
            ymax = self.get_ymax(y_data, 0)
            ymin = min(0, min(y_data))
        elif self.ylim == 'minmax':
            ymax = max(y_data)
            ymin = min(0, min(y_data))
        if self.dmin is not None:
            xmax = 1.0 / self.dmin**2

        #ax1.grid(True)
        ax1.set_xlim(xmin, xmax)
        ax1.set_ylim(ymin, ymax)


        # Plot the mean intensity
        #if self.data_type == 'I':
        #  ax1.plot(i_res_squared, mean_iobs, color="Orange", lw=1)

        # Loop through ice ring resolutions and plot
        for lb, ub in zip(*self.ice_rings):
            rectangle = matplotlib.patches.Rectangle(
                (lb, ymin),
                ub - lb,
                ymax - ymin, 
                color="grey", 
                zorder=1, 
                alpha=0.15, 
                linewidth=0)
            ax1.add_patch(rectangle)

        have_ice_rings_been_flagged = False
        if not self.no_automatic:
            for idx in range(auspex_handle.Size()):
                if auspex_handle.IcefinderScore(idx) >= self.cutoff or auspex_handle.IcefinderScore(idx) <= -self.cutoff:
                    if auspex_handle.IsInIceRing(idx) == 1:
                        for lb, ub in zip(*self.ice_rings): 
                            if auspex_handle.MeanIResSquared(idx) >= lb and auspex_handle.MeanIResSquared(idx) <= ub:
                                rectangle = matplotlib.patches.Rectangle(
                                    (lb, ymin),
                                    ub - lb,
                                    ymax - ymin, 
                                    color="red", 
                                    zorder=1, 
                                    alpha=0.15, 
                                    linewidth=0)
                                ax1.add_patch(rectangle)
                                have_ice_rings_been_flagged = True

        if have_ice_rings_been_flagged:
            from os.path import exists
            outfile = open("mtz_with_ice_rings.txt", "a")
            print(self.mtzfilename, file=outfile)

        # Save the figure and clear
        if self.ax is None:
            filename = os.path.join(self.output_directory, self.filename)
            plt.savefig(filename, dpi=self.dpi, bbox_inches='tight')
            plt.clf()



class IPlot(GenericPlot):
    '''
    Plot the I vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(IPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "I_plot.png"
        self.title = r'$\mathrm{I_{obs}}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{I_{obs}}$'
        self.data_type = 'I'

class SigIPlot(GenericPlot):
    '''
    Plot the Sig(I) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(SigIPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "SigI_plot.png"
        self.title = r'$\mathrm{\sigma(I_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{\sigma(I_{obs})}$'
        self.data_type = 'SigI'


class IoverSigIPlot(GenericPlot):
    '''
    Plot the I / Sig(I) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(IoverSigIPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "ISigI_plot.png"
        self.title = r'$\mathrm{I_{obs} / \sigma(I_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{I_{obs} / \sigma(I_{obs})}$'
        self.data_type = 'ISigI'


class FPlot(GenericPlot):
    '''
    Plot the F vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(FPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "F_plot.png"
        self.title = r'$\mathrm{F_{obs}}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{F_{obs}}$'
        self.data_type = 'F'


class SigFPlot(GenericPlot):
    '''
    Plot the Sig(F) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(SigFPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "SigF_plot.png"
        self.title = r'$\mathrm{\sigma(F_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{\sigma(F_{obs})}$'
        self.data_type = 'SigF'

class FoverSigFPlot(GenericPlot):
    '''
    Plot the F / Sig(F) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(FoverSigFPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "FSigF_plot.png"
        self.title = r'$\mathrm{F_{obs} / \sigma(F_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{F_{obs} / \sigma(F_{obs})}$'
        self.data_type = 'FSigF'

class BPlot(GenericPlot):
    '''
    Plot the B vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(BPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "B_plot.png"
        self.title = r'$\mathrm{B_{obs}}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{B_{obs}}$'
        self.data_type = 'B'

class SigBPlot(GenericPlot):
    '''
    Plot the Sig(B) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(SigBPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "SigB_plot.png"
        self.title = r'$\mathrm{\sigma(B_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{\sigma(B_{obs})}$'
        self.data_type = 'SigB'


class BoverSigBPlot(GenericPlot):
    '''
    Plot the B / Sig(B) vs resolution

    '''
    def __init__(self, ice_rings, **kwargs):
        super(BoverSigBPlot, self).__init__(ice_rings, **kwargs)
        self.filename = "BSigB_plot.png"
        self.title = r'$\mathrm{B_{obs} / \sigma(B_{obs})}$ vs. resolution'
        self.xlabel = r'resolution $\mathrm{(\AA)}$'
        self.ylabel = r'$\mathrm{B_{obs} / \sigma(B_{obs})}$'
        self.data_type = 'BSigB'

class PlotGenerator(object):
    '''
    A class to generate all the plots for this data

    '''

    # This is how a constructor is done in python; it never returns a value (just like in C++).
    # "self" is always the first argument, just like this in C++, but it has to be explicit!
    def __init__(self, 
                 hexagonal_ice_path, 
                 auspex_handle,
                 filename=None,
                 ylim=None,
                 output_directory=None,
                 dmin=None,
                 filename_in_title=False,
                 single_figure=False,
                 score_figure=False,
                 no_individual_figures=False,
                 num_xticks=10,
                 cutoff=5,
                 no_automatic=False):
        ''' 
        Initialise the generator

        '''
        # Figure properties
        self.plotwidth = 10
        self.dpi = 300

        # Save some parameters
        self.filename = filename
        self.output_directory = output_directory
        self.ylim = ylim
        self.dmin = dmin
        self.filename_in_title = filename_in_title

        # Set num x ticks
        self.num_xticks = num_xticks

        # Save auspex handle
        self.auspex_handle = auspex_handle

        # Read the hexagonal ice resolution file
        reader = IceRingTextReader(hexagonal_ice_path)

        # Save the ice ring resolutions
        self.ice_rings = (reader.lower, reader.upper)

        # A single figure or separate
        self.single_figure = single_figure

        # Extra mode for icefinder score
        self.score_figure = score_figure

        #Do individual figures:
        self.no_individual_figures = no_individual_figures

        # Save the cutoff value
        self.cutoff = cutoff

        # Save automatic ice ring flagging yes/no
        self.no_automatic = no_automatic

    def generate_I_plot(self, I, SigI, D2, ax=None):
        '''
        Generate the I plot

        '''
        plot = IPlot(
            self.ice_rings,
            ax                = ax,
            filename          = self.filename,
            output_directory  = self.output_directory,
            cutoff            = self.cutoff,
            ylim              = self.ylim,
            dmin              = self.dmin,
            num_xticks        = self.num_xticks,
            filename_in_title = self.filename_in_title,
            no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, I)

    def generate_SigI_plot(self, I, SigI, D2, ax=None):
        '''
        Generate the SigI plot

        '''
        plot = SigIPlot(self.ice_rings,
                        ax                = ax,
                        filename          = self.filename,
                        output_directory  = self.output_directory,
                        cutoff            = self.cutoff,
                        ylim              = self.ylim,
                        dmin              = self.dmin,
                        num_xticks        = self.num_xticks,
                        filename_in_title = self.filename_in_title,
                        no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, SigI)

    def generate_ISigI_plot(self, I, SigI, D2, ax=None):
        '''
        Generate the I / SigI plot

        '''
        D2, ISigI = list(zip(*[(d, i / sigi) for d, i, sigi in zip(D2, I, SigI) if sigi > 0]))
        plot = IoverSigIPlot(self.ice_rings,
                             ax                = ax,
                             filename          = self.filename,
                             output_directory  = self.output_directory,
                             cutoff            = self.cutoff,
                             ylim              = self.ylim,
                             dmin              = self.dmin,
                             num_xticks        = self.num_xticks,
                             filename_in_title = self.filename_in_title,
                             no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, ISigI)

    def generate_standardised_mean_plot(self, I, D2, ax=None):
        xmax = max(D2)
        xmin = min(0, min(D2))


        standardised_mean = []
        estimated_standardised_mean = []
        i_res_squared = []
        for idx in range(self.auspex_handle.Size()):
            i_res_squared.append(self.auspex_handle.MeanIResSquared(idx))
            standardised_mean.append(self.auspex_handle.ObsStandardisedMean(idx))
            estimated_standardised_mean.append(self.auspex_handle.EstimatedStandardisedMean(idx))

        #Define function that calculates 1/x^2
        def formatter(x, p):
            if x <= 0:
                return ''
            else:
                return '%.2f' % math.sqrt(1.0/x)

        # Set the number of x ticks
        ax.set_xticks(
            np.arange(
                min(D2), 
                max(D2), 
                0.99*(max(D2) - min(D2)) / (self.num_xticks-1)))
        ax.get_xaxis().set_major_formatter(matplotlib.ticker.FuncFormatter(formatter))
        ax.set_ylabel("observed standardized mean")
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(-2, 4)
        ax.axhline(1, color='#415a55', alpha=0.5)
        ax.plot(i_res_squared, estimated_standardised_mean,  color="Red", lw=1)    
        ax.plot(i_res_squared, standardised_mean,  color="Black", lw=1)

    def generate_icefinderscore_plot(self, I, D2, ax=None):

        icefinderscore = []
        i_res_squared = []
        for idx in range(self.auspex_handle.Size()):
            i_res_squared.append(self.auspex_handle.MeanIResSquared(idx))
            icefinderscore.append(self.auspex_handle.IcefinderScore(idx))

        xmax = max(D2)
        xmin = min(0, min(D2))
        #Define function that calculates 1/x^2
        def formatter(x, p):
            if x <= 0:
                return ''
            else:
                return '%.2f' % math.sqrt(1.0/x)

        # Set the number of x ticks
        ax.set_xticks(
            np.arange(
                min(D2), 
                max(D2), 
                0.99*(max(D2) - min(D2)) / (self.num_xticks-1)))

        ax.get_xaxis().set_major_formatter(matplotlib.ticker.FuncFormatter(formatter))
        # Set the number of x ticks

        ax.set_ylabel("icefinderscore")
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(-10, 10)
        ax.axhline(self.cutoff, color='red', alpha=0.5)
        ax.axhline(-self.cutoff, color='red', alpha=0.5)
        ax.axhline(0, color='#415a55', alpha=0.5)
        ax.plot(i_res_squared, icefinderscore,  color="Black", lw=1)

    def generate_F_plot(self, F, SigF, D2, ax=None):
        '''
        Generate the F plot

        '''
        plot = FPlot(self.ice_rings,
                     ax                = ax,
                     filename          = self.filename,
                     output_directory  = self.output_directory,
                     cutoff            = self.cutoff,
                     ylim              = self.ylim,
                     dmin              = self.dmin,
                     num_xticks        = self.num_xticks,
                     filename_in_title = self.filename_in_title,
                     no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, F)

    def generate_SigF_plot(self, F, SigF, D2, ax=None):
        '''
        Generate the SigF plot

        '''
        plot = SigFPlot(self.ice_rings,
                        ax                = ax,
                        filename          = self.filename,
                        output_directory  = self.output_directory,
                        cutoff            = self.cutoff,
                        ylim              = self.ylim,
                        dmin              = self.dmin,
                        num_xticks        = self.num_xticks,
                        filename_in_title = self.filename_in_title,
                        no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, SigF)

    def generate_FSigF_plot(self, F, SigF, D2, ax=None):
        '''
        Generate the F / SigF plot

        '''
        D2, FSigF = list(zip(*[(d, f / sigf) for d, f, sigf in zip(D2, F, SigF) if sigf > 0]))
        plot = FoverSigFPlot(self.ice_rings,
                             ax                = ax,
                             filename          = self.filename,
                             output_directory  = self.output_directory,
                             cutoff            = self.cutoff,
                             ylim              = self.ylim,
                             dmin              = self.dmin,
                             num_xticks        = self.num_xticks,
                             filename_in_title = self.filename_in_title,
                             no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, FSigF)
    
    def generate_B_plot(self, B, SigB, D2, ax=None):
        '''
        Generate the B plot

        '''
        plot = BPlot(
            self.ice_rings,
            ax                = ax,
            filename          = self.filename,
            output_directory  = self.output_directory,
            cutoff            = self.cutoff,
            ylim              = self.ylim,
            dmin              = self.dmin,
            num_xticks        = self.num_xticks,
            filename_in_title = self.filename_in_title,
            no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, B)

    def generate_SigB_plot(self, B, SigB, D2, ax=None):
        '''
        Generate the SigB plot

        '''
        plot = SigBPlot(self.ice_rings,
                        ax                = ax,
                        filename          = self.filename,
                        output_directory  = self.output_directory,
                        cutoff            = self.cutoff,
                        ylim              = self.ylim,
                        dmin              = self.dmin,
                        num_xticks        = self.num_xticks,
                        filename_in_title = self.filename_in_title,
                        no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, SigB)

    def generate_BSigB_plot(self, B, SigB, D2, ax=None):
        '''
        Generate the B / SigB plot

        '''
        D2, BSigB = list(zip(*[(d, b / sigb) for d, b, sigb in zip(D2, B, SigB) if sigb > 0]))
        plot = BoverSigBPlot(self.ice_rings,
                             ax                = ax,
                             filename          = self.filename,
                             output_directory  = self.output_directory,
                             cutoff            = self.cutoff,
                             ylim              = self.ylim,
                             dmin              = self.dmin,
                             num_xticks        = self.num_xticks,
                             filename_in_title = self.filename_in_title,
                             no_automatic      = self.no_automatic)
        plot.generate(self.auspex_handle, D2, BSigB)

    def generate(self, auspex_handle):
        '''
        Generate all the plots

        '''


        # Get the data
        i_data = auspex_handle.GetIntensityData()
        f_data = auspex_handle.GetAmplitudeData()
        b_data = auspex_handle.GetBackgroundData()
        print("_______________________________________________________________________________\n")
        print("                                GENERATING PLOTS:                              ")
        print("        (Depending on the size of the data set, this may take a moment)        \n")

        if i_data.size() > 0:
            print('Set of plots is generated with %s intensities.' % (i_data.size()))
            reso_data = [x.ires_squared for x in i_data]
            iobs    =  [y.obs for y in i_data]
            isigma  =  [y.sigma for y in i_data]

            if self.single_figure: 
                figure = plt.figure(figsize=(self.plotwidth, np.sqrt(2)*self.plotwidth))
                ax1 = figure.add_subplot(3, 1, 1)
                ax2 = figure.add_subplot(3, 1, 2)
                ax3 = figure.add_subplot(3, 1, 3)
                self.generate_I_plot(iobs, isigma, reso_data, ax=ax1)
                self.generate_SigI_plot(iobs, isigma, reso_data, ax=ax2)
                self.generate_ISigI_plot(iobs, isigma, reso_data, ax=ax3)
                filename = os.path.join(self.output_directory, "intensities.png")
                plt.tight_layout()
                plt.savefig(filename, dpi=self.dpi, bbox_inches='tight')
                plt.clf()
                #print "single figure: %s" % (self.single_figure)

            if not self.no_individual_figures:
                ax1 = None
                ax2 = None
                ax3 = None
                # Generate intensity plots
                self.generate_I_plot(iobs, isigma, reso_data, ax=ax1)
                self.generate_SigI_plot(iobs, isigma, reso_data, ax=ax2)
                self.generate_ISigI_plot(iobs, isigma, reso_data, ax=ax3)

            if self.score_figure:
                figure = plt.figure(figsize=(self.plotwidth, np.sqrt(2)*self.plotwidth))
                ax1 = figure.add_subplot(3, 1, 1)
                ax2 = figure.add_subplot(3, 1, 2)
                ax3 = figure.add_subplot(3, 1, 3)
                self.generate_standardised_mean_plot(iobs, reso_data, ax=ax1)
                self.generate_icefinderscore_plot(iobs, reso_data, ax=ax2)
                self.generate_I_plot(iobs, isigma, reso_data, ax=ax3)
                filename = os.path.join(self.output_directory, "score.png")
                plt.tight_layout()
                plt.savefig(filename, dpi=self.dpi, bbox_inches='tight')
                plt.clf()
                print("\nGenerating a score figure: %s\n" % (self.score_figure))  

        if f_data.size() > 0:
            print('Set of plots is generated with %s amplitudes.' % (f_data.size()))
            reso_data =  [x.ires_squared for x in f_data]
            fobs    =  [y.obs for y in f_data]
            fsigma  =  [y.sigma for y in f_data]

            if self.single_figure: 
                figure = plt.figure(figsize=(self.plotwidth, np.sqrt(2)*self.plotwidth))
                ax1 = figure.add_subplot(3, 1, 1)
                ax2 = figure.add_subplot(3, 1, 2)
                ax3 = figure.add_subplot(3, 1, 3)
                # Generate amplitude plots
                self.generate_F_plot(fobs, fsigma, reso_data, ax=ax1)
                self.generate_SigF_plot(fobs, fsigma, reso_data, ax=ax2)
                self.generate_FSigF_plot(fobs, fsigma, reso_data, ax=ax3)      
                filename = os.path.join(self.output_directory, "amplitudes.png")
                plt.tight_layout()
                plt.savefig(filename, dpi=self.dpi, bbox_inches='tight')
                plt.clf()

            if not self.no_individual_figures:
                ax1 = None
                ax2 = None
                ax3 = None
                # Generate amplitude plots
                self.generate_F_plot(fobs, fsigma, reso_data, ax=ax1)
                self.generate_SigF_plot(fobs, fsigma, reso_data, ax=ax2)
                self.generate_FSigF_plot(fobs, fsigma, reso_data, ax=ax3)

        if b_data.size() > 0:
            print('Set of plots is generated with %s backgrounds.' % (b_data.size()))
            reso_data = [x.ires_squared for x in b_data]
            bobs    =  [y.obs for y in b_data]
            bsigma  =  [y.sigma for y in b_data]

            if self.single_figure: 
                figure = plt.figure(figsize=(self.plotwidth, np.sqrt(2)*self.plotwidth))
                ax1 = figure.add_subplot(3, 1, 1)
                ax2 = figure.add_subplot(3, 1, 2)
                ax3 = figure.add_subplot(3, 1, 3)
                self.generate_B_plot(bobs, bsigma, reso_data, ax=ax1)
                self.generate_SigB_plot(bobs, bsigma, reso_data, ax=ax2)
                self.generate_BSigB_plot(bobs, bsigma, reso_data, ax=ax3)
                filename = os.path.join(self.output_directory, "backgrounds.png")
                plt.tight_layout()
                plt.savefig(filename, dpi=self.dpi, bbox_inches='tight')
                plt.clf()
                #print "single figure: %s" % (self.single_figure)

            if not self.no_individual_figures:
                ax1 = None
                ax2 = None
                ax3 = None
                # Generate intensity plots
                self.generate_B_plot(bobs, bsigma, reso_data, ax=ax1)
                self.generate_SigB_plot(bobs, bsigma, reso_data, ax=ax2)
                self.generate_BSigB_plot(bobs, bsigma, reso_data, ax=ax3)


def get_auspex_object_from_mtz(mtz_filename, binning, cutoff, debug_mode,
                               use_anom_if_present):
    a = auspex.Auspex(mtz_filename, binning, use_anom_if_present)
    if not a.empty():
        if debug_mode:
            print("Filename: ",a.Filename())
            print("Number of reflections in %s" % (a.Filename()))
            print("Number of bins: ",a.Size())
            idx=100
            print("Looking at bin: ",idx)
            #print "Size: ",a.Size(idx)
            #print "LowIResSquared: ",a.LowIResSquared(idx)
            #print "HighIResSquared: ",a.HighIResSquared(idx)
            #print "MeanIResSquared: ",a.MeanIResSquared(idx)
            #print "Weakest5PC: ",a.Weakest5PC(idx)
            #print "Strongest5PC: ",a.Strongest5PC(idx)
            #print "ObsMean: ",a.ObsMean(idx)
            #print "ObsVar: ",a.ObsVar(idx)
            #print "ObsStandardisedMean: ",a.ObsStandardisedMean(idx)
            #print "IcefinderScore: ",a.IcefinderScore(idx)
            #print "String Representation: ",a.String(idx)
            #print 'IceRingSummaryVector: \n', '\n'.join(a.IceRingSummaryVector())
            print('Cutoff: ', cutoff)
            from collections import defaultdict
            robs_table = defaultdict(lambda: False)

            for idx in range(a.Size()):
                if a.IcefinderScore(idx) >= cutoff or a.IcefinderScore(idx) <= -cutoff:
                    if a.IsInIceRing(idx) == 1:
                        robs_table[a.IceRingID(idx)] = True

            summary = []
            for row in a.IceRingSummaryVector():
                print(row)
                ice_ring_index = int(row.split()[0])
                flag = robs_table[ice_ring_index]
                #summary.append(row + "\t%r\t%s\t%s" % (flag, binning, cutoff))
                summary.append(row + "\t%s" % (binning))

            outfile2 = open("diagnostics.txt", "w")
            #print >>outfile2, "IceringID\tScoreLowest\tScoreHighest\tflagged\tbinning\tcutoff"
            print("IceringID\tScoreLowest\tScoreHighest\tNObsLowest\tNObsHighest\tCellVolume\tResLimit\tNonIceScoreIQR", file=outfile2)
            print("%s" % ('\n'.join(summary)), file=outfile2)
            exit(0)
        return a


if __name__ == "__main__":

    import sys
    command_line = ' '.join(sys.argv[1:])

    parser = argparse.ArgumentParser(
        description='AUSPEX',
        formatter_class=RawTextHelpFormatter
    )

    parser.add_argument(
        'hklin', 
        metavar='HKLIN', 
        type=str, 
        nargs=1,
        help='The mtz file to be analyzed.')

    parser.add_argument(
        '--directory', 
        dest='directory', 
        type=str, 
        default='.',
        help='The output directory.')

    parser.add_argument(
        '--ylim', 
        dest='ylim', 
        type=str, 
        default='auto',
        help='''Specify the y limit mode for the plots. Options:
minmax\tPlot everything.
auto\tPlot only core of distribution automatically (default).
auto_low\tPlot only core of distribution automatically, with a focus of lower values.
        low\tPlot only values below mean.''')

    parser.add_argument(
        '--dmin', 
        dest='dmin', 
        type=float, 
        default=None,
        help='Specify the maximum resolution to show in the plots.')

    parser.add_argument(
        '--no-filename-in-title', 
        dest='no_filename_in_title', 
        action='store_true',
        default=False,
        help='Should the filename be shown in the title? (Options: true / false)')

    parser.add_argument(
        '--single-figure', 
        dest='single_figure', 
        action='store_true',
        default=False,
        help='Should the images be generated in separate png files? (Default: No.)')

    parser.add_argument(
        '--score-figure', 
        dest='score_figure', 
        action='store_true',
        default=False,
        help='Should only a scoring image be generated instead of usual output? (Default: No.)')

    parser.add_argument(
        '--no-individual', 
        dest='no_individual_figures', 
        action='store_true',
        default=False,
        help='Should individual figures not be made for each plot?  (Default: No; set option for Yes.)')

    parser.add_argument(
        '--no-automatic', 
        dest='no_automatic', 
        action='store_true',
        default=False,
        help='If set, no ice rings will be flagged by red bars.')

    parser.add_argument(
        '--cutoff', 
        dest='cutoff', 
        type=float, 
        default=5,
        help='Specify the cut off for IceFinderScore (default: 5).')

    parser.add_argument(
        '--binning', 
        dest='binning', 
        type=float, 
        default=0.001,
        help='Specify the bin size for individual bins, in 1/Angstroem (default: 0.001).')

    parser.add_argument(
        '--debug-mode', 
        dest='debug_mode', 
        action='store_true',
        default=False,
        help='Debug mode. No plots, but a diagnostic file and more screen output.')
    
    parser.add_argument(
        '--text-output', 
        dest='text_filename', 
        default=None,
        help='Write out a text file with the mtz columns')

    parser.add_argument(
        '--dont-use-anom-if-present', 
        dest='use_anom_if_present', 
        action="store_false",
        default=True,
        help='Use I(+)/I(-) and F(+)/F(-) for plots if present')

    args = parser.parse_args()

    mtz_filename = args.hklin[0]
    output_directory = args.directory
    version = "1.1b"

    print("")
    print("            ######################################################## ")
    print("           #                    _   _   _ ____  ____  _______  __   #")
    print("           #       A           / \ | | | / ___||  _ \| ____\ \/ /   #")
    print("           #   /MmmOmmM\      / _ \| | | \___ \| |_) |  _|  \  /    #")
    print("           #       #         / ___ \ |_| |___) |  __/| |___ /  \    #")
    print("           #      /#\       /_/   \_\___/|____/|_|   |_____/_/\_\   #")
    print("           #                                        {:>13s}   #".format("Version " + str(version)))
    print("            ######################################################## ")

    print("\nCOMMAND LINE: auspex %s" % (command_line))

    if exists(mtz_filename):
        # Original line
        # share = os.path.join(sysconfig.PREFIX, 'share')
        # For CCP4:
        share = os.path.join(os.environ['AUSPEX_INSTALL_BASE'], 'share')
        auspex_package_dir = os.path.join(share, 'auspex')
        auspex_package_data_dir = os.path.join(auspex_package_dir, 'data')
        hexagonal_file_path = os.path.join(auspex_package_data_dir, 'hexagonal.txt')
        if (not os.path.exists(hexagonal_file_path)):
            raise IOError('''
                The file %s does not exist. 
                Perhaps the AUSPEX_INSTALL_BASE environment variable is incorrect
            ''' % hexagonal_file_path)

        auspex_info = get_auspex_object_from_mtz(
            mtz_filename, 
            binning=args.binning, 
            cutoff=args.cutoff, 
            debug_mode=args.debug_mode,
            use_anom_if_present=args.use_anom_if_present)

        # Write a text file
        if args.text_filename is not None:
            auspex_info.WriteTextFile(args.text_filename)

        plot = PlotGenerator(
            hexagonal_file_path, 
            auspex_info,
            filename=args.hklin[0],
            output_directory=args.directory,
            ylim=args.ylim,
            dmin=args.dmin,
            filename_in_title=not args.no_filename_in_title,
            single_figure=args.single_figure,
            score_figure=args.score_figure,
            no_individual_figures=args.no_individual_figures,
            cutoff=args.cutoff,
            no_automatic=args.no_automatic)
        name_stub = splitext(basename(mtz_filename))[0]

        plot.name_stub = name_stub #  = join(output_directory, "%s.png" % )

        plot.generate(auspex_info)

    else:
        print("File %s does not exist." % (mtz_filename))
